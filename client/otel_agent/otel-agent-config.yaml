receivers:
  hostmetrics:
    root_path: /host/root
    collection_interval: "${env:COLLECTION_INTERVAL}"
    scrapers:
      cpu:
      memory:
      network:
      filesystem:
      load:
      disk:

  docker_stats:
    endpoint: "unix:///var/run/docker.sock"
    api_version: "${env:DOCKER_API_VERSION}"
    collection_interval: "${env:COLLECTION_INTERVAL}"
    metrics:
      container.cpu.usage.total: { enabled: true }
      container.memory.usage.total: { enabled: true }
      container.network.io.usage.rx_bytes: { enabled: true }
      container.network.io.usage.tx_bytes: { enabled: true }
      container.uptime: { enabled: true }

  filelog:
    include:
      - "${env:APP_LOG_DIR}/**/*.log"
    include_file_path: true
    multiline:
      line_start_pattern: '^\d{4}-\d{2}-\d{2}' # ← 날짜만 체크
    retry_on_failure:
      enabled: true
      initial_interval: 1s
      max_interval: 30s
      max_elapsed_time: 5m
    operators:
      - type: regex_parser
        parse_from: attributes["log.file.path"]
        regex: '.*/(?P<env>[^/]+)/(?P<container>[^/]+)/[^/]+\.log$'

      - type: move
        from: attributes.container
        to: resource["container.name"]

      # - type: move
      #   from: attributes.env
      #   to: attributes["deployment.environment"]
      - type: remove
        field: attributes.env
        if: "attributes.env != nil"

      - type: remove
        field: attributes.ts
        if: "attributes.ts != nil"

processors:
  resourcedetection:
    detectors: [env, system, docker]
    timeout: 5s
    override: false

  resource/node_mapping:
    attributes:
      # host.name (NODE_ID) → env로 복사
      - key: env
        from_attribute: host.name
        action: upsert

  resource/service_mapping:
    attributes:

      - key: container.name
        from_attribute: container  # ← attributes에서 가져옴
        action: upsert
      # container.name이 있으면 service.name으로 설정
      - key: service.name
        from_attribute: container.name
        action: upsert
      
      # Datadog service 태그
      - key: service
        from_attribute: container.name
        action: upsert

  batch:
    send_batch_size: 512
    send_batch_max_size: 1024
    timeout: 5s

  memory_limiter:
    check_interval: 1s
    limit_mib: ${env:MEMORY_LIMIT_MIB}
    spike_limit_mib: 128

  filter/drop_otel:
    error_mode: ignore
    logs:
      log_record:
        - 'IsMatch(resource.attributes["container.image.name"], "otel/opentelemetry-collector")'
        - 'IsMatch(resource.attributes["container.name"], "otel-agent")'

exporters:
  # otlp:
  #   # http://127.0.0.1:4317 등 .env 주소 사용
  #   endpoint: "http://${env:OTEL_COLLECTOR_HOST}"
  #   tls:
  #     insecure: true
  #   headers:
  #     # [Gateway 인증] .env의 토큰 사용
  #     Authorization: "Bearer ${env:GATEWAY_AUTH_TOKEN}"

  otlphttp:
    endpoint: "http://${env:OTEL_COLLECTOR_HOST}"
    headers:
      Authorization: "Bearer ${env:GATEWAY_AUTH_TOKEN}"
    tls:
      insecure: true
    sending_queue:
      enabled: true
      num_consumers: 10
      queue_size: 20000

    retry_on_failure:
      enabled: true
      initial_interval: 2s
      max_interval: 30s
      max_elapsed_time: 5m

  debug:
    verbosity: detailed

service:
  pipelines:
    metrics:
      receivers: [hostmetrics, docker_stats]
      processors: [resourcedetection, resource/node_mapping, resource/service_mapping,  memory_limiter, batch]
      # exporters: [otlp]
      exporters: [otlphttp, debug]

    logs:
      # [중요] 두 리시버 모두 포함해야 함
      receivers: [filelog]
      processors:
        [
          resourcedetection,
          resource/node_mapping,
          resource/service_mapping,
          filter/drop_otel,
          memory_limiter,
          # attributes/cleanup,
          batch,
        ]
      # exporters: [otlp] # 문제 해결 후 debug 제거
      exporters: [otlphttp, debug]
