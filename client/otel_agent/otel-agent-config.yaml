receivers:
  hostmetrics:
    root_path: /host/root
    collection_interval: "${env:COLLECTION_INTERVAL}"
    scrapers:
      cpu:
      memory:
      network:
      filesystem:
        include_mount_points:
          mount_points:
            - /host/root # 호스트의 / (Root)
            - /host/root/aitrics-vc # 호스트의 /aitrics-vc
      load:
      disk:

  docker_stats:
    endpoint: "unix:///var/run/docker.sock"
    api_version: "${env:DOCKER_API_VERSION}"
    collection_interval: "${env:COLLECTION_INTERVAL}"
    metrics:
      container.cpu.usage.total: { enabled: true }
      container.memory.usage.total: { enabled: true }
      container.network.io.usage.rx_bytes: { enabled: true }
      container.network.io.usage.tx_bytes: { enabled: true }
      container.uptime: { enabled: true }
      container.restarts: { enabled: true } #재시작 횟수를 통해 + uptime을 통해 상태 추적
      container.name: { enabled: true } #컨테이너 이름
      container.image.id: { enabled: true } #컨테이너 이미지 id
      container.image.name: { enabled: true } #컨테이너 이미지 이름

  filelog:
    include:
      - "${env:APP_LOG_DIR}/**/*.log"
    include_file_path: true
    multiline:
      line_start_pattern: '^\d{4}-\d{2}-\d{2}' # ← 날짜만 체크
    retry_on_failure:
      enabled: true
      initial_interval: 1s
      max_interval: 30s
      max_elapsed_time: 5m
    operators:
      - type: regex_parser
        parse_from: attributes["log.file.path"]
        regex: '.*/(?P<env>[^/]+)/(?P<container>[^/]+)/[^/]+\.log$'

      - type: move
        from: attributes.container
        to: resource["container.name"]

      # - type: move
      #   from: attributes.env
      #   to: attributes["deployment.environment"]
      - type: remove
        field: attributes.env
        if: "attributes.env != nil"

      - type: remove
        field: attributes.ts
        if: "attributes.ts != nil"
  sqlquery:
    driver: mysql
    datasource: "${MYSQL_USER}:${MYSQL_PASSWORD}@tcp(${MYSQL_HOST}:${MYSQL_PORT})/${MYSQL_DB}"
    collection_interval: 10s
    queries:
      - sql: "SELECT count(*) as encounters FROM emr_encounter WHERE discharge_dt is NULL" # 실제 쿼리로 수정
        metrics:
          - metric_name: mysql.se.encounter_count
            value_column: encounters
            value_type: int
      - sql: >
          SELECT COUNT(*) AS encounters
          FROM emr_score
          WHERE created_dt >= DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:00'), INTERVAL (MINUTE(NOW()) % 10) + 10 MINUTE)
            AND created_dt <  DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:00'), INTERVAL (MINUTE(NOW()) % 10) MINUTE)
        metrics:
          - metric_name: mysql.se.score_count
            value_column: encounters
            value_type: int

processors:
  resourcedetection:
    detectors: [env, system, docker]
    timeout: 5s
    override: false

  resource/node_mapping:
    attributes:
      # host.name (NODE_ID) → env로 복사
      - key: env
        from_attribute: host.name
        action: upsert

  resource/service_mapping:
    attributes:
      - key: container.name
        from_attribute: container # ← attributes에서 가져옴
        action: upsert
      - key: container.name
        value: "se-monitoring-tools"
        action: insert
      # container.name이 있으면 service.name으로 설정
      - key: service.name
        from_attribute: container.name
        action: upsert

      # Datadog service 태그
      - key: service
        from_attribute: container.name
        action: upsert

  batch:
    send_batch_size: 512
    send_batch_max_size: 1024
    timeout: 5s

  memory_limiter:
    check_interval: 1s
    limit_mib: ${env:MEMORY_LIMIT_MIB}
    spike_limit_mib: 128

  filter/drop_otel:
    error_mode: ignore
    logs:
      log_record:
        - 'IsMatch(resource.attributes["container.image.name"], "otel/opentelemetry-collector")'
        - 'IsMatch(resource.attributes["container.name"], "otel-agent")'

exporters:
  # otlp:
  #   # http://127.0.0.1:4317 등 .env 주소 사용
  #   endpoint: "http://${env:OTEL_COLLECTOR_HOST}"
  #   tls:
  #     insecure: true
  #   headers:
  #     # [Gateway 인증] .env의 토큰 사용
  #     Authorization: "Bearer ${env:GATEWAY_AUTH_TOKEN}"

  otlphttp:
    endpoint: "http://${env:OTEL_COLLECTOR_HOST}"
    headers:
      Authorization: "Bearer ${env:GATEWAY_AUTH_TOKEN}"
    tls:
      insecure: true
    sending_queue:
      enabled: true
      num_consumers: 10
      queue_size: 20000

    retry_on_failure:
      enabled: true
      initial_interval: 2s
      max_interval: 30s
      max_elapsed_time: 5m

  debug:
    verbosity: detailed

service:
  pipelines:
    metrics:
      # receivers: [hostmetrics, docker_stats, sqlquery]
      receivers: [hostmetrics, docker_stats, sqlquery]
      processors:
        [
          resourcedetection,
          resource/node_mapping,
          resource/service_mapping,
          memory_limiter,
          batch,
        ]
      # exporters: [otlp]
      exporters: [otlphttp, debug]

    logs:
      # [중요] 두 리시버 모두 포함해야 함
      receivers: [filelog]
      processors: [
          resourcedetection,
          resource/node_mapping,
          resource/service_mapping,
          filter/drop_otel,
          memory_limiter,
          # attributes/cleanup,
          batch,
        ]
      # exporters: [otlp] # 문제 해결 후 debug 제거
      exporters: [otlphttp]
